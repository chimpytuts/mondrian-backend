"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

scalar Bytes

type Claimed {
    address: Bytes!
    block: BigInt!
    id: ID!
    owner: XUser
    timestamp: BigInt!
    total: BigInt!
}

input Claimed_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_in: [Bytes!]
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    owner: String
    owner_: XUser_filter
    owner_contains: String
    owner_contains_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_gt: String
    owner_gte: String
    owner_in: [String!]
    owner_lt: String
    owner_lte: String
    owner_not: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    owner_not_in: [String!]
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    total: BigInt
    total_gt: BigInt
    total_gte: BigInt
    total_in: [BigInt!]
    total_lt: BigInt
    total_lte: BigInt
    total_not: BigInt
    total_not_in: [BigInt!]
}

enum Claimed_orderBy {
    address
    block
    id
    owner
    timestamp
    total
}

type Governance {
    block: BigInt!
    id: ID!
    purposalCount: BigInt!
    purposals(
        first: Int = 100
        orderBy: Purposal_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Purposal_filter
    ): [Purposal!]
    quorumVotes: BigInt!
    timestamp: BigInt!
}

input Governance_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    purposalCount: BigInt
    purposalCount_gt: BigInt
    purposalCount_gte: BigInt
    purposalCount_in: [BigInt!]
    purposalCount_lt: BigInt
    purposalCount_lte: BigInt
    purposalCount_not: BigInt
    purposalCount_not_in: [BigInt!]
    purposals_: Purposal_filter
    quorumVotes: BigInt
    quorumVotes_gt: BigInt
    quorumVotes_gte: BigInt
    quorumVotes_in: [BigInt!]
    quorumVotes_lt: BigInt
    quorumVotes_lte: BigInt
    quorumVotes_not: BigInt
    quorumVotes_not_in: [BigInt!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
}

enum Governance_orderBy {
    block
    id
    purposalCount
    purposals
    quorumVotes
    timestamp
}

type Lock {
    action: Int!
    amount: BigInt!
    block: BigInt!
    id: ID!
    locktime: BigInt!
    owner: XUser
    timestamp: BigInt!
}

input Lock_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    action: Int
    action_gt: Int
    action_gte: Int
    action_in: [Int!]
    action_lt: Int
    action_lte: Int
    action_not: Int
    action_not_in: [Int!]
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    locktime: BigInt
    locktime_gt: BigInt
    locktime_gte: BigInt
    locktime_in: [BigInt!]
    locktime_lt: BigInt
    locktime_lte: BigInt
    locktime_not: BigInt
    locktime_not_in: [BigInt!]
    owner: String
    owner_: XUser_filter
    owner_contains: String
    owner_contains_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_gt: String
    owner_gte: String
    owner_in: [String!]
    owner_lt: String
    owner_lte: String
    owner_not: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    owner_not_in: [String!]
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
}

enum Lock_orderBy {
    action
    amount
    block
    id
    locktime
    owner
    timestamp
}

type MasterChef {
    block: BigInt!
    embrPerSec: BigInt!
    id: ID!
    poolCount: BigInt!
    pools(
        first: Int = 100
        orderBy: Pool_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Pool_filter
    ): [Pool!]
    timestamp: BigInt!
    totalAllocPoint: BigInt!
}

input MasterChef_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    embrPerSec: BigInt
    embrPerSec_gt: BigInt
    embrPerSec_gte: BigInt
    embrPerSec_in: [BigInt!]
    embrPerSec_lt: BigInt
    embrPerSec_lte: BigInt
    embrPerSec_not: BigInt
    embrPerSec_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    poolCount: BigInt
    poolCount_gt: BigInt
    poolCount_gte: BigInt
    poolCount_in: [BigInt!]
    poolCount_lt: BigInt
    poolCount_lte: BigInt
    poolCount_not: BigInt
    poolCount_not_in: [BigInt!]
    pools_: Pool_filter
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    totalAllocPoint: BigInt
    totalAllocPoint_gt: BigInt
    totalAllocPoint_gte: BigInt
    totalAllocPoint_in: [BigInt!]
    totalAllocPoint_lt: BigInt
    totalAllocPoint_lte: BigInt
    totalAllocPoint_not: BigInt
    totalAllocPoint_not_in: [BigInt!]
}

enum MasterChef_orderBy {
    block
    embrPerSec
    id
    poolCount
    pools
    timestamp
    totalAllocPoint
}

type Migrations {
    block: BigInt!
    claimed: BigInt!
    id: ID!
    timestamp: BigInt!
    unclaimed: BigInt!
}

input Migrations_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    claimed: BigInt
    claimed_gt: BigInt
    claimed_gte: BigInt
    claimed_in: [BigInt!]
    claimed_lt: BigInt
    claimed_lte: BigInt
    claimed_not: BigInt
    claimed_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    unclaimed: BigInt
    unclaimed_gt: BigInt
    unclaimed_gte: BigInt
    unclaimed_in: [BigInt!]
    unclaimed_lt: BigInt
    unclaimed_lte: BigInt
    unclaimed_not: BigInt
    unclaimed_not_in: [BigInt!]
}

enum Migrations_orderBy {
    block
    claimed
    id
    timestamp
    unclaimed
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
    asc
    desc
}

type Pool {
    accEmbrPerShare: BigInt!
    allocPoint: BigInt!
    block: BigInt!
    id: ID!
    lastRewardBlock: BigInt!
    masterChef: MasterChef!
    pair: Bytes!
    rewarder: Rewarder
    slpBalance: BigInt!
    timestamp: BigInt!
    userCount: BigInt!
    users(
        first: Int = 100
        orderBy: User_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: User_filter
    ): [User!]!
}

input Pool_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    accEmbrPerShare: BigInt
    accEmbrPerShare_gt: BigInt
    accEmbrPerShare_gte: BigInt
    accEmbrPerShare_in: [BigInt!]
    accEmbrPerShare_lt: BigInt
    accEmbrPerShare_lte: BigInt
    accEmbrPerShare_not: BigInt
    accEmbrPerShare_not_in: [BigInt!]
    allocPoint: BigInt
    allocPoint_gt: BigInt
    allocPoint_gte: BigInt
    allocPoint_in: [BigInt!]
    allocPoint_lt: BigInt
    allocPoint_lte: BigInt
    allocPoint_not: BigInt
    allocPoint_not_in: [BigInt!]
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    lastRewardBlock: BigInt
    lastRewardBlock_gt: BigInt
    lastRewardBlock_gte: BigInt
    lastRewardBlock_in: [BigInt!]
    lastRewardBlock_lt: BigInt
    lastRewardBlock_lte: BigInt
    lastRewardBlock_not: BigInt
    lastRewardBlock_not_in: [BigInt!]
    masterChef: String
    masterChef_: MasterChef_filter
    masterChef_contains: String
    masterChef_contains_nocase: String
    masterChef_ends_with: String
    masterChef_ends_with_nocase: String
    masterChef_gt: String
    masterChef_gte: String
    masterChef_in: [String!]
    masterChef_lt: String
    masterChef_lte: String
    masterChef_not: String
    masterChef_not_contains: String
    masterChef_not_contains_nocase: String
    masterChef_not_ends_with: String
    masterChef_not_ends_with_nocase: String
    masterChef_not_in: [String!]
    masterChef_not_starts_with: String
    masterChef_not_starts_with_nocase: String
    masterChef_starts_with: String
    masterChef_starts_with_nocase: String
    pair: Bytes
    pair_contains: Bytes
    pair_in: [Bytes!]
    pair_not: Bytes
    pair_not_contains: Bytes
    pair_not_in: [Bytes!]
    rewarder: String
    rewarder_: Rewarder_filter
    rewarder_contains: String
    rewarder_contains_nocase: String
    rewarder_ends_with: String
    rewarder_ends_with_nocase: String
    rewarder_gt: String
    rewarder_gte: String
    rewarder_in: [String!]
    rewarder_lt: String
    rewarder_lte: String
    rewarder_not: String
    rewarder_not_contains: String
    rewarder_not_contains_nocase: String
    rewarder_not_ends_with: String
    rewarder_not_ends_with_nocase: String
    rewarder_not_in: [String!]
    rewarder_not_starts_with: String
    rewarder_not_starts_with_nocase: String
    rewarder_starts_with: String
    rewarder_starts_with_nocase: String
    slpBalance: BigInt
    slpBalance_gt: BigInt
    slpBalance_gte: BigInt
    slpBalance_in: [BigInt!]
    slpBalance_lt: BigInt
    slpBalance_lte: BigInt
    slpBalance_not: BigInt
    slpBalance_not_in: [BigInt!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    userCount: BigInt
    userCount_gt: BigInt
    userCount_gte: BigInt
    userCount_in: [BigInt!]
    userCount_lt: BigInt
    userCount_lte: BigInt
    userCount_not: BigInt
    userCount_not_in: [BigInt!]
    users_: User_filter
}

enum Pool_orderBy {
    accEmbrPerShare
    allocPoint
    block
    id
    lastRewardBlock
    masterChef
    pair
    rewarder
    slpBalance
    timestamp
    userCount
    users
}

type Purposal {
    againstVotes: BigInt!
    block: BigInt!
    details: String!
    duration: BigInt!
    endDate: BigInt!
    executed: Boolean!
    executor: Bytes!
    forVotes: BigInt!
    governance: Governance
    id: ID!
    index: BigInt!
    metadata: String!
    proposer: XUser!
    startDate: BigInt!
    state: BigInt!
    timestamp: BigInt!
    title: String!
}

input Purposal_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    againstVotes: BigInt
    againstVotes_gt: BigInt
    againstVotes_gte: BigInt
    againstVotes_in: [BigInt!]
    againstVotes_lt: BigInt
    againstVotes_lte: BigInt
    againstVotes_not: BigInt
    againstVotes_not_in: [BigInt!]
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    details: String
    details_contains: String
    details_contains_nocase: String
    details_ends_with: String
    details_ends_with_nocase: String
    details_gt: String
    details_gte: String
    details_in: [String!]
    details_lt: String
    details_lte: String
    details_not: String
    details_not_contains: String
    details_not_contains_nocase: String
    details_not_ends_with: String
    details_not_ends_with_nocase: String
    details_not_in: [String!]
    details_not_starts_with: String
    details_not_starts_with_nocase: String
    details_starts_with: String
    details_starts_with_nocase: String
    duration: BigInt
    duration_gt: BigInt
    duration_gte: BigInt
    duration_in: [BigInt!]
    duration_lt: BigInt
    duration_lte: BigInt
    duration_not: BigInt
    duration_not_in: [BigInt!]
    endDate: BigInt
    endDate_gt: BigInt
    endDate_gte: BigInt
    endDate_in: [BigInt!]
    endDate_lt: BigInt
    endDate_lte: BigInt
    endDate_not: BigInt
    endDate_not_in: [BigInt!]
    executed: Boolean
    executed_in: [Boolean!]
    executed_not: Boolean
    executed_not_in: [Boolean!]
    executor: Bytes
    executor_contains: Bytes
    executor_in: [Bytes!]
    executor_not: Bytes
    executor_not_contains: Bytes
    executor_not_in: [Bytes!]
    forVotes: BigInt
    forVotes_gt: BigInt
    forVotes_gte: BigInt
    forVotes_in: [BigInt!]
    forVotes_lt: BigInt
    forVotes_lte: BigInt
    forVotes_not: BigInt
    forVotes_not_in: [BigInt!]
    governance: String
    governance_: Governance_filter
    governance_contains: String
    governance_contains_nocase: String
    governance_ends_with: String
    governance_ends_with_nocase: String
    governance_gt: String
    governance_gte: String
    governance_in: [String!]
    governance_lt: String
    governance_lte: String
    governance_not: String
    governance_not_contains: String
    governance_not_contains_nocase: String
    governance_not_ends_with: String
    governance_not_ends_with_nocase: String
    governance_not_in: [String!]
    governance_not_starts_with: String
    governance_not_starts_with_nocase: String
    governance_starts_with: String
    governance_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    index: BigInt
    index_gt: BigInt
    index_gte: BigInt
    index_in: [BigInt!]
    index_lt: BigInt
    index_lte: BigInt
    index_not: BigInt
    index_not_in: [BigInt!]
    metadata: String
    metadata_contains: String
    metadata_contains_nocase: String
    metadata_ends_with: String
    metadata_ends_with_nocase: String
    metadata_gt: String
    metadata_gte: String
    metadata_in: [String!]
    metadata_lt: String
    metadata_lte: String
    metadata_not: String
    metadata_not_contains: String
    metadata_not_contains_nocase: String
    metadata_not_ends_with: String
    metadata_not_ends_with_nocase: String
    metadata_not_in: [String!]
    metadata_not_starts_with: String
    metadata_not_starts_with_nocase: String
    metadata_starts_with: String
    metadata_starts_with_nocase: String
    proposer: String
    proposer_: XUser_filter
    proposer_contains: String
    proposer_contains_nocase: String
    proposer_ends_with: String
    proposer_ends_with_nocase: String
    proposer_gt: String
    proposer_gte: String
    proposer_in: [String!]
    proposer_lt: String
    proposer_lte: String
    proposer_not: String
    proposer_not_contains: String
    proposer_not_contains_nocase: String
    proposer_not_ends_with: String
    proposer_not_ends_with_nocase: String
    proposer_not_in: [String!]
    proposer_not_starts_with: String
    proposer_not_starts_with_nocase: String
    proposer_starts_with: String
    proposer_starts_with_nocase: String
    startDate: BigInt
    startDate_gt: BigInt
    startDate_gte: BigInt
    startDate_in: [BigInt!]
    startDate_lt: BigInt
    startDate_lte: BigInt
    startDate_not: BigInt
    startDate_not_in: [BigInt!]
    state: BigInt
    state_gt: BigInt
    state_gte: BigInt
    state_in: [BigInt!]
    state_lt: BigInt
    state_lte: BigInt
    state_not: BigInt
    state_not_in: [BigInt!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    title: String
    title_contains: String
    title_contains_nocase: String
    title_ends_with: String
    title_ends_with_nocase: String
    title_gt: String
    title_gte: String
    title_in: [String!]
    title_lt: String
    title_lte: String
    title_not: String
    title_not_contains: String
    title_not_contains_nocase: String
    title_not_ends_with: String
    title_not_ends_with_nocase: String
    title_not_in: [String!]
    title_not_starts_with: String
    title_not_starts_with_nocase: String
    title_starts_with: String
    title_starts_with_nocase: String
}

enum Purposal_orderBy {
    againstVotes
    block
    details
    duration
    endDate
    executed
    executor
    forVotes
    governance
    id
    index
    metadata
    proposer
    startDate
    state
    timestamp
    title
}

type Query {
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
    claimed(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Claimed
    claimeds(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Claimed_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Claimed_filter
    ): [Claimed!]!
    governance(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Governance
    governances(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Governance_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Governance_filter
    ): [Governance!]!
    lock(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Lock
    locks(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Lock_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Lock_filter
    ): [Lock!]!
    masterChef(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MasterChef
    masterChefs(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: MasterChef_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: MasterChef_filter
    ): [MasterChef!]!
    migrations(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Migrations_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Migrations_filter
    ): [Migrations!]!
    pool(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Pool
    pools(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Pool_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Pool_filter
    ): [Pool!]!
    purposal(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Purposal
    purposals(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Purposal_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Purposal_filter
    ): [Purposal!]!
    reward(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Reward
    rewardInfo(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RewardInfo
    rewardInfos(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: RewardInfo_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: RewardInfo_filter
    ): [RewardInfo!]!
    rewarder(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Rewarder
    rewarders(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Rewarder_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Rewarder_filter
    ): [Rewarder!]!
    rewards(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Reward_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Reward_filter
    ): [Reward!]!
    user(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): User
    users(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: User_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: User_filter
    ): [User!]!
    xembr(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): XEmbr
    xembrs(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: XEmbr_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: XEmbr_filter
    ): [XEmbr!]!
    xuser(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): XUser
    xusers(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: XUser_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: XUser_filter
    ): [XUser!]!
}

type Reward {
    address: Bytes!
    block: BigInt!
    claimed: BigInt!
    id: ID!
    index: BigInt!
    owner: XUser
    timestamp: BigInt!
}

type RewardInfo {
    active: Boolean!
    address: Bytes!
    block: BigInt!
    claimed: BigInt!
    expiry: BigInt!
    id: ID!
    index: BigInt!
    timestamp: BigInt!
    unclaimed: BigInt!
    xembr: XEmbr
}

input RewardInfo_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    active: Boolean
    active_in: [Boolean!]
    active_not: Boolean
    active_not_in: [Boolean!]
    address: Bytes
    address_contains: Bytes
    address_in: [Bytes!]
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    claimed: BigInt
    claimed_gt: BigInt
    claimed_gte: BigInt
    claimed_in: [BigInt!]
    claimed_lt: BigInt
    claimed_lte: BigInt
    claimed_not: BigInt
    claimed_not_in: [BigInt!]
    expiry: BigInt
    expiry_gt: BigInt
    expiry_gte: BigInt
    expiry_in: [BigInt!]
    expiry_lt: BigInt
    expiry_lte: BigInt
    expiry_not: BigInt
    expiry_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    index: BigInt
    index_gt: BigInt
    index_gte: BigInt
    index_in: [BigInt!]
    index_lt: BigInt
    index_lte: BigInt
    index_not: BigInt
    index_not_in: [BigInt!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    unclaimed: BigInt
    unclaimed_gt: BigInt
    unclaimed_gte: BigInt
    unclaimed_in: [BigInt!]
    unclaimed_lt: BigInt
    unclaimed_lte: BigInt
    unclaimed_not: BigInt
    unclaimed_not_in: [BigInt!]
    xembr: String
    xembr_: XEmbr_filter
    xembr_contains: String
    xembr_contains_nocase: String
    xembr_ends_with: String
    xembr_ends_with_nocase: String
    xembr_gt: String
    xembr_gte: String
    xembr_in: [String!]
    xembr_lt: String
    xembr_lte: String
    xembr_not: String
    xembr_not_contains: String
    xembr_not_contains_nocase: String
    xembr_not_ends_with: String
    xembr_not_ends_with_nocase: String
    xembr_not_in: [String!]
    xembr_not_starts_with: String
    xembr_not_starts_with_nocase: String
    xembr_starts_with: String
    xembr_starts_with_nocase: String
}

enum RewardInfo_orderBy {
    active
    address
    block
    claimed
    expiry
    id
    index
    timestamp
    unclaimed
    xembr
}

input Reward_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_in: [Bytes!]
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    claimed: BigInt
    claimed_gt: BigInt
    claimed_gte: BigInt
    claimed_in: [BigInt!]
    claimed_lt: BigInt
    claimed_lte: BigInt
    claimed_not: BigInt
    claimed_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    index: BigInt
    index_gt: BigInt
    index_gte: BigInt
    index_in: [BigInt!]
    index_lt: BigInt
    index_lte: BigInt
    index_not: BigInt
    index_not_in: [BigInt!]
    owner: String
    owner_: XUser_filter
    owner_contains: String
    owner_contains_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_gt: String
    owner_gte: String
    owner_in: [String!]
    owner_lt: String
    owner_lte: String
    owner_not: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    owner_not_in: [String!]
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
}

enum Reward_orderBy {
    address
    block
    claimed
    id
    index
    owner
    timestamp
}

type Rewarder {
    block: BigInt!
    id: ID!
    rewardPerSecond: BigInt!
    rewardToken: Bytes!
    timestamp: BigInt!
}

input Rewarder_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    rewardPerSecond: BigInt
    rewardPerSecond_gt: BigInt
    rewardPerSecond_gte: BigInt
    rewardPerSecond_in: [BigInt!]
    rewardPerSecond_lt: BigInt
    rewardPerSecond_lte: BigInt
    rewardPerSecond_not: BigInt
    rewardPerSecond_not_in: [BigInt!]
    rewardToken: Bytes
    rewardToken_contains: Bytes
    rewardToken_in: [Bytes!]
    rewardToken_not: Bytes
    rewardToken_not_contains: Bytes
    rewardToken_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
}

enum Rewarder_orderBy {
    block
    id
    rewardPerSecond
    rewardToken
    timestamp
}

type Subscription {
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
    claimed(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Claimed
    claimeds(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Claimed_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Claimed_filter
    ): [Claimed!]!
    governance(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Governance
    governances(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Governance_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Governance_filter
    ): [Governance!]!
    lock(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Lock
    locks(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Lock_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Lock_filter
    ): [Lock!]!
    masterChef(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MasterChef
    masterChefs(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: MasterChef_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: MasterChef_filter
    ): [MasterChef!]!
    migrations(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Migrations_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Migrations_filter
    ): [Migrations!]!
    pool(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Pool
    pools(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Pool_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Pool_filter
    ): [Pool!]!
    purposal(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Purposal
    purposals(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Purposal_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Purposal_filter
    ): [Purposal!]!
    reward(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Reward
    rewardInfo(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RewardInfo
    rewardInfos(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: RewardInfo_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: RewardInfo_filter
    ): [RewardInfo!]!
    rewarder(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Rewarder
    rewarders(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Rewarder_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Rewarder_filter
    ): [Rewarder!]!
    rewards(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Reward_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Reward_filter
    ): [Reward!]!
    user(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): User
    users(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: User_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: User_filter
    ): [User!]!
    xembr(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): XEmbr
    xembrs(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: XEmbr_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: XEmbr_filter
    ): [XEmbr!]!
    xuser(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): XUser
    xusers(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: XUser_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: XUser_filter
    ): [XUser!]!
}

type User {
    address: Bytes!
    amount: BigInt!
    block: BigInt!
    embrHarvested: BigInt!
    id: ID!
    pool: Pool
    rewardDebt: BigInt!
    timestamp: BigInt!
}

input User_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_in: [Bytes!]
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    embrHarvested: BigInt
    embrHarvested_gt: BigInt
    embrHarvested_gte: BigInt
    embrHarvested_in: [BigInt!]
    embrHarvested_lt: BigInt
    embrHarvested_lte: BigInt
    embrHarvested_not: BigInt
    embrHarvested_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    pool: String
    pool_: Pool_filter
    pool_contains: String
    pool_contains_nocase: String
    pool_ends_with: String
    pool_ends_with_nocase: String
    pool_gt: String
    pool_gte: String
    pool_in: [String!]
    pool_lt: String
    pool_lte: String
    pool_not: String
    pool_not_contains: String
    pool_not_contains_nocase: String
    pool_not_ends_with: String
    pool_not_ends_with_nocase: String
    pool_not_in: [String!]
    pool_not_starts_with: String
    pool_not_starts_with_nocase: String
    pool_starts_with: String
    pool_starts_with_nocase: String
    rewardDebt: BigInt
    rewardDebt_gt: BigInt
    rewardDebt_gte: BigInt
    rewardDebt_in: [BigInt!]
    rewardDebt_lt: BigInt
    rewardDebt_lte: BigInt
    rewardDebt_not: BigInt
    rewardDebt_not_in: [BigInt!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
}

enum User_orderBy {
    address
    amount
    block
    embrHarvested
    id
    pool
    rewardDebt
    timestamp
}

type XEmbr {
    activeTokenCount: BigInt!
    block: BigInt!
    id: ID!
    rewards(
        first: Int = 100
        orderBy: RewardInfo_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: RewardInfo_filter
    ): [RewardInfo!]!
    staking: BigInt!
    timestamp: BigInt!
    tokenCount: BigInt!
    userCount: BigInt!
    users(
        first: Int = 100
        orderBy: XUser_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: XUser_filter
    ): [XUser!]
}

input XEmbr_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    activeTokenCount: BigInt
    activeTokenCount_gt: BigInt
    activeTokenCount_gte: BigInt
    activeTokenCount_in: [BigInt!]
    activeTokenCount_lt: BigInt
    activeTokenCount_lte: BigInt
    activeTokenCount_not: BigInt
    activeTokenCount_not_in: [BigInt!]
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    rewards_: RewardInfo_filter
    staking: BigInt
    staking_gt: BigInt
    staking_gte: BigInt
    staking_in: [BigInt!]
    staking_lt: BigInt
    staking_lte: BigInt
    staking_not: BigInt
    staking_not_in: [BigInt!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    tokenCount: BigInt
    tokenCount_gt: BigInt
    tokenCount_gte: BigInt
    tokenCount_in: [BigInt!]
    tokenCount_lt: BigInt
    tokenCount_lte: BigInt
    tokenCount_not: BigInt
    tokenCount_not_in: [BigInt!]
    userCount: BigInt
    userCount_gt: BigInt
    userCount_gte: BigInt
    userCount_in: [BigInt!]
    userCount_lt: BigInt
    userCount_lte: BigInt
    userCount_not: BigInt
    userCount_not_in: [BigInt!]
    users_: XUser_filter
}

enum XEmbr_orderBy {
    activeTokenCount
    block
    id
    rewards
    staking
    timestamp
    tokenCount
    userCount
    users
}

type XUser {
    block: BigInt!
    claimed(
        first: Int = 100
        orderBy: Claimed_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Claimed_filter
    ): [Claimed!]
    expiry: BigInt!
    id: ID!
    locks(
        first: Int = 100
        orderBy: Lock_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Lock_filter
    ): [Lock!]
    owner: Bytes!
    purposals(
        first: Int = 100
        orderBy: Purposal_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Purposal_filter
    ): [Purposal!]
    rewards(
        first: Int = 100
        orderBy: Reward_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Reward_filter
    ): [Reward!]
    staking: BigInt!
    start: BigInt!
    timestamp: BigInt!
    xembr: XEmbr
}

input XUser_filter {
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    claimed_: Claimed_filter
    expiry: BigInt
    expiry_gt: BigInt
    expiry_gte: BigInt
    expiry_in: [BigInt!]
    expiry_lt: BigInt
    expiry_lte: BigInt
    expiry_not: BigInt
    expiry_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    locks_: Lock_filter
    owner: Bytes
    owner_contains: Bytes
    owner_in: [Bytes!]
    owner_not: Bytes
    owner_not_contains: Bytes
    owner_not_in: [Bytes!]
    purposals_: Purposal_filter
    rewards_: Reward_filter
    staking: BigInt
    staking_gt: BigInt
    staking_gte: BigInt
    staking_in: [BigInt!]
    staking_lt: BigInt
    staking_lte: BigInt
    staking_not: BigInt
    staking_not_in: [BigInt!]
    start: BigInt
    start_gt: BigInt
    start_gte: BigInt
    start_in: [BigInt!]
    start_lt: BigInt
    start_lte: BigInt
    start_not: BigInt
    start_not_in: [BigInt!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    xembr: String
    xembr_: XEmbr_filter
    xembr_contains: String
    xembr_contains_nocase: String
    xembr_ends_with: String
    xembr_ends_with_nocase: String
    xembr_gt: String
    xembr_gte: String
    xembr_in: [String!]
    xembr_lt: String
    xembr_lte: String
    xembr_not: String
    xembr_not_contains: String
    xembr_not_contains_nocase: String
    xembr_not_ends_with: String
    xembr_not_ends_with_nocase: String
    xembr_not_in: [String!]
    xembr_not_starts_with: String
    xembr_not_starts_with_nocase: String
    xembr_starts_with: String
    xembr_starts_with_nocase: String
}

enum XUser_orderBy {
    block
    claimed
    expiry
    id
    locks
    owner
    purposals
    rewards
    staking
    start
    timestamp
    xembr
}

type _Block_ {
    """
    The hash of the block
    """
    hash: Bytes

    """
    The block number
    """
    number: Int!
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
    "Information about a specific subgraph block. The hash of the block\nwill be null if the _meta field has a block constraint that asks for\na block number. It will be filled if the _meta field has no block constraint\nand therefore asks for the latest  block\n"
    block: _Block_!

    """
    The deployment ID
    """
    deployment: String!

    """
    If `true`, the subgraph encountered indexing errors at some past block
    """
    hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
    """
    Data will be returned even if the subgraph has indexing errors
    """
    allow

    """
    If the subgraph has indexing errors, data will be omitted. The default.
    """
    deny
}
