"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

scalar BigDecimal

scalar BigInt

type Block {
    """
    Author
    """
    author: Bytes!

    """
    Difficulty
    """
    difficulty: BigInt!

    """
    Gas Limit
    """
    gasLimit: BigInt!

    """
    Gas Used
    """
    gasUsed: BigInt!

    """
    ID (hash)
    """
    id: ID!

    """
    Number
    """
    number: BigInt!

    """
    Parent Hash
    """
    parentHash: Bytes!

    """
    Receipts Root
    """
    receiptsRoot: Bytes!

    """
    Size
    """
    size: BigInt

    """
    State Root
    """
    stateRoot: Bytes!

    """
    Timestamp
    """
    timestamp: BigInt!

    """
    Total Difficulty
    """
    totalDifficulty: BigInt!

    """
    Transactions Root
    """
    transactionsRoot: Bytes!

    """
    Uncles Hash
    """
    unclesHash: Bytes!
}

input Block_filter {
    author: Bytes
    author_contains: Bytes
    author_in: [Bytes!]
    author_not: Bytes
    author_not_contains: Bytes
    author_not_in: [Bytes!]
    difficulty: BigInt
    difficulty_gt: BigInt
    difficulty_gte: BigInt
    difficulty_in: [BigInt!]
    difficulty_lt: BigInt
    difficulty_lte: BigInt
    difficulty_not: BigInt
    difficulty_not_in: [BigInt!]
    gasLimit: BigInt
    gasLimit_gt: BigInt
    gasLimit_gte: BigInt
    gasLimit_in: [BigInt!]
    gasLimit_lt: BigInt
    gasLimit_lte: BigInt
    gasLimit_not: BigInt
    gasLimit_not_in: [BigInt!]
    gasUsed: BigInt
    gasUsed_gt: BigInt
    gasUsed_gte: BigInt
    gasUsed_in: [BigInt!]
    gasUsed_lt: BigInt
    gasUsed_lte: BigInt
    gasUsed_not: BigInt
    gasUsed_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    number: BigInt
    number_gt: BigInt
    number_gte: BigInt
    number_in: [BigInt!]
    number_lt: BigInt
    number_lte: BigInt
    number_not: BigInt
    number_not_in: [BigInt!]
    parentHash: Bytes
    parentHash_contains: Bytes
    parentHash_in: [Bytes!]
    parentHash_not: Bytes
    parentHash_not_contains: Bytes
    parentHash_not_in: [Bytes!]
    receiptsRoot: Bytes
    receiptsRoot_contains: Bytes
    receiptsRoot_in: [Bytes!]
    receiptsRoot_not: Bytes
    receiptsRoot_not_contains: Bytes
    receiptsRoot_not_in: [Bytes!]
    size: BigInt
    size_gt: BigInt
    size_gte: BigInt
    size_in: [BigInt!]
    size_lt: BigInt
    size_lte: BigInt
    size_not: BigInt
    size_not_in: [BigInt!]
    stateRoot: Bytes
    stateRoot_contains: Bytes
    stateRoot_in: [Bytes!]
    stateRoot_not: Bytes
    stateRoot_not_contains: Bytes
    stateRoot_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    totalDifficulty: BigInt
    totalDifficulty_gt: BigInt
    totalDifficulty_gte: BigInt
    totalDifficulty_in: [BigInt!]
    totalDifficulty_lt: BigInt
    totalDifficulty_lte: BigInt
    totalDifficulty_not: BigInt
    totalDifficulty_not_in: [BigInt!]
    transactionsRoot: Bytes
    transactionsRoot_contains: Bytes
    transactionsRoot_in: [Bytes!]
    transactionsRoot_not: Bytes
    transactionsRoot_not_contains: Bytes
    transactionsRoot_not_in: [Bytes!]
    unclesHash: Bytes
    unclesHash_contains: Bytes
    unclesHash_in: [Bytes!]
    unclesHash_not: Bytes
    unclesHash_not_contains: Bytes
    unclesHash_not_in: [Bytes!]
}

"""
The block at which the query should be executed.
"""
input Block_height {
    """
    Value containing a block hash
    """
    hash: Bytes

    """
    Value containing a block number
    """
    number: Int

    "Value containing the minimum block number. \nIn the case of `number_gte`, the query will be executed on the latest block only if\nthe subgraph has progressed to or past the minimum block number.\nDefaults to the latest block when omitted.\n"
    number_gte: Int
}

enum Block_orderBy {
    author
    difficulty
    gasLimit
    gasUsed
    id
    number
    parentHash
    receiptsRoot
    size
    stateRoot
    timestamp
    totalDifficulty
    transactionsRoot
    unclesHash
}

type Bundle {
    """
    BNB price, in USD
    """
    bnbPrice: BigDecimal!
    id: ID!
}

input Bundle_filter {
    bnbPrice: BigDecimal
    bnbPrice_gt: BigDecimal
    bnbPrice_gte: BigDecimal
    bnbPrice_in: [BigDecimal!]
    bnbPrice_lt: BigDecimal
    bnbPrice_lte: BigDecimal
    bnbPrice_not: BigDecimal
    bnbPrice_not_in: [BigDecimal!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
}

enum Bundle_orderBy {
    bnbPrice
    id
}

type Burn {
    amount0: BigDecimal
    amount1: BigDecimal
    amountUSD: BigDecimal
    feeLiquidity: BigDecimal
    feeTo: Bytes
    id: ID!
    liquidity: BigDecimal!
    logIndex: BigInt
    needsComplete: Boolean!
    pair: Pair!
    sender: Bytes
    timestamp: BigInt!
    to: Bytes
    transaction: Transaction!
}

input Burn_filter {
    amount0: BigDecimal
    amount0_gt: BigDecimal
    amount0_gte: BigDecimal
    amount0_in: [BigDecimal!]
    amount0_lt: BigDecimal
    amount0_lte: BigDecimal
    amount0_not: BigDecimal
    amount0_not_in: [BigDecimal!]
    amount1: BigDecimal
    amount1_gt: BigDecimal
    amount1_gte: BigDecimal
    amount1_in: [BigDecimal!]
    amount1_lt: BigDecimal
    amount1_lte: BigDecimal
    amount1_not: BigDecimal
    amount1_not_in: [BigDecimal!]
    amountUSD: BigDecimal
    amountUSD_gt: BigDecimal
    amountUSD_gte: BigDecimal
    amountUSD_in: [BigDecimal!]
    amountUSD_lt: BigDecimal
    amountUSD_lte: BigDecimal
    amountUSD_not: BigDecimal
    amountUSD_not_in: [BigDecimal!]
    feeLiquidity: BigDecimal
    feeLiquidity_gt: BigDecimal
    feeLiquidity_gte: BigDecimal
    feeLiquidity_in: [BigDecimal!]
    feeLiquidity_lt: BigDecimal
    feeLiquidity_lte: BigDecimal
    feeLiquidity_not: BigDecimal
    feeLiquidity_not_in: [BigDecimal!]
    feeTo: Bytes
    feeTo_contains: Bytes
    feeTo_in: [Bytes!]
    feeTo_not: Bytes
    feeTo_not_contains: Bytes
    feeTo_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    liquidity: BigDecimal
    liquidity_gt: BigDecimal
    liquidity_gte: BigDecimal
    liquidity_in: [BigDecimal!]
    liquidity_lt: BigDecimal
    liquidity_lte: BigDecimal
    liquidity_not: BigDecimal
    liquidity_not_in: [BigDecimal!]
    logIndex: BigInt
    logIndex_gt: BigInt
    logIndex_gte: BigInt
    logIndex_in: [BigInt!]
    logIndex_lt: BigInt
    logIndex_lte: BigInt
    logIndex_not: BigInt
    logIndex_not_in: [BigInt!]
    needsComplete: Boolean
    needsComplete_in: [Boolean!]
    needsComplete_not: Boolean
    needsComplete_not_in: [Boolean!]
    pair: String
    pair_contains: String
    pair_ends_with: String
    pair_gt: String
    pair_gte: String
    pair_in: [String!]
    pair_lt: String
    pair_lte: String
    pair_not: String
    pair_not_contains: String
    pair_not_ends_with: String
    pair_not_in: [String!]
    pair_not_starts_with: String
    pair_starts_with: String
    sender: Bytes
    sender_contains: Bytes
    sender_in: [Bytes!]
    sender_not: Bytes
    sender_not_contains: Bytes
    sender_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    to: Bytes
    to_contains: Bytes
    to_in: [Bytes!]
    to_not: Bytes
    to_not_contains: Bytes
    to_not_in: [Bytes!]
    transaction: String
    transaction_contains: String
    transaction_ends_with: String
    transaction_gt: String
    transaction_gte: String
    transaction_in: [String!]
    transaction_lt: String
    transaction_lte: String
    transaction_not: String
    transaction_not_contains: String
    transaction_not_ends_with: String
    transaction_not_in: [String!]
    transaction_not_starts_with: String
    transaction_starts_with: String
}

enum Burn_orderBy {
    amount0
    amount1
    amountUSD
    feeLiquidity
    feeTo
    id
    liquidity
    logIndex
    needsComplete
    pair
    sender
    timestamp
    to
    transaction
}

scalar Bytes

type Mint {
    amount0: BigDecimal
    amount1: BigDecimal
    amountUSD: BigDecimal
    feeLiquidity: BigDecimal
    feeTo: Bytes
    id: ID!
    liquidity: BigDecimal!
    logIndex: BigInt
    pair: Pair!
    sender: Bytes
    timestamp: BigInt!
    to: Bytes!
    transaction: Transaction!
}

input Mint_filter {
    amount0: BigDecimal
    amount0_gt: BigDecimal
    amount0_gte: BigDecimal
    amount0_in: [BigDecimal!]
    amount0_lt: BigDecimal
    amount0_lte: BigDecimal
    amount0_not: BigDecimal
    amount0_not_in: [BigDecimal!]
    amount1: BigDecimal
    amount1_gt: BigDecimal
    amount1_gte: BigDecimal
    amount1_in: [BigDecimal!]
    amount1_lt: BigDecimal
    amount1_lte: BigDecimal
    amount1_not: BigDecimal
    amount1_not_in: [BigDecimal!]
    amountUSD: BigDecimal
    amountUSD_gt: BigDecimal
    amountUSD_gte: BigDecimal
    amountUSD_in: [BigDecimal!]
    amountUSD_lt: BigDecimal
    amountUSD_lte: BigDecimal
    amountUSD_not: BigDecimal
    amountUSD_not_in: [BigDecimal!]
    feeLiquidity: BigDecimal
    feeLiquidity_gt: BigDecimal
    feeLiquidity_gte: BigDecimal
    feeLiquidity_in: [BigDecimal!]
    feeLiquidity_lt: BigDecimal
    feeLiquidity_lte: BigDecimal
    feeLiquidity_not: BigDecimal
    feeLiquidity_not_in: [BigDecimal!]
    feeTo: Bytes
    feeTo_contains: Bytes
    feeTo_in: [Bytes!]
    feeTo_not: Bytes
    feeTo_not_contains: Bytes
    feeTo_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    liquidity: BigDecimal
    liquidity_gt: BigDecimal
    liquidity_gte: BigDecimal
    liquidity_in: [BigDecimal!]
    liquidity_lt: BigDecimal
    liquidity_lte: BigDecimal
    liquidity_not: BigDecimal
    liquidity_not_in: [BigDecimal!]
    logIndex: BigInt
    logIndex_gt: BigInt
    logIndex_gte: BigInt
    logIndex_in: [BigInt!]
    logIndex_lt: BigInt
    logIndex_lte: BigInt
    logIndex_not: BigInt
    logIndex_not_in: [BigInt!]
    pair: String
    pair_contains: String
    pair_ends_with: String
    pair_gt: String
    pair_gte: String
    pair_in: [String!]
    pair_lt: String
    pair_lte: String
    pair_not: String
    pair_not_contains: String
    pair_not_ends_with: String
    pair_not_in: [String!]
    pair_not_starts_with: String
    pair_starts_with: String
    sender: Bytes
    sender_contains: Bytes
    sender_in: [Bytes!]
    sender_not: Bytes
    sender_not_contains: Bytes
    sender_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    to: Bytes
    to_contains: Bytes
    to_in: [Bytes!]
    to_not: Bytes
    to_not_contains: Bytes
    to_not_in: [Bytes!]
    transaction: String
    transaction_contains: String
    transaction_ends_with: String
    transaction_gt: String
    transaction_gte: String
    transaction_in: [String!]
    transaction_lt: String
    transaction_lte: String
    transaction_not: String
    transaction_not_contains: String
    transaction_not_ends_with: String
    transaction_not_in: [String!]
    transaction_not_starts_with: String
    transaction_starts_with: String
}

enum Mint_orderBy {
    amount0
    amount1
    amountUSD
    feeLiquidity
    feeTo
    id
    liquidity
    logIndex
    pair
    sender
    timestamp
    to
    transaction
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
    asc
    desc
}

type Pair {
    block: BigInt!
    burns(
        first: Int = 100
        orderBy: Burn_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Burn_filter
    ): [Burn!]!
    id: ID!
    mints(
        first: Int = 100
        orderBy: Mint_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Mint_filter
    ): [Mint!]!
    name: String!
    pairHourData(
        first: Int = 100
        orderBy: PairHourData_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: PairHourData_filter
    ): [PairHourData!]!
    reserve0: BigDecimal!
    reserve1: BigDecimal!
    reserveBNB: BigDecimal!
    reserveUSD: BigDecimal!
    swaps(
        first: Int = 100
        orderBy: Swap_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Swap_filter
    ): [Swap!]!
    timestamp: BigInt!
    token0: Token!
    token0Price: BigDecimal!
    token1: Token!
    token1Price: BigDecimal!
    totalSupply: BigDecimal!
    totalTransactions: BigInt!
    trackedReserveBNB: BigDecimal!
    untrackedVolumeUSD: BigDecimal!
    volumeToken0: BigDecimal!
    volumeToken1: BigDecimal!
    volumeUSD: BigDecimal!
}

type PairDayData {
    dailyTxns: BigInt!
    dailyVolumeToken0: BigDecimal!
    dailyVolumeToken1: BigDecimal!
    dailyVolumeUSD: BigDecimal!
    date: Int!
    id: ID!
    pairAddress: Bytes!
    reserve0: BigDecimal!
    reserve1: BigDecimal!
    reserveUSD: BigDecimal!
    token0: Token!
    token1: Token!
    totalSupply: BigDecimal!
}

input PairDayData_filter {
    dailyTxns: BigInt
    dailyTxns_gt: BigInt
    dailyTxns_gte: BigInt
    dailyTxns_in: [BigInt!]
    dailyTxns_lt: BigInt
    dailyTxns_lte: BigInt
    dailyTxns_not: BigInt
    dailyTxns_not_in: [BigInt!]
    dailyVolumeToken0: BigDecimal
    dailyVolumeToken0_gt: BigDecimal
    dailyVolumeToken0_gte: BigDecimal
    dailyVolumeToken0_in: [BigDecimal!]
    dailyVolumeToken0_lt: BigDecimal
    dailyVolumeToken0_lte: BigDecimal
    dailyVolumeToken0_not: BigDecimal
    dailyVolumeToken0_not_in: [BigDecimal!]
    dailyVolumeToken1: BigDecimal
    dailyVolumeToken1_gt: BigDecimal
    dailyVolumeToken1_gte: BigDecimal
    dailyVolumeToken1_in: [BigDecimal!]
    dailyVolumeToken1_lt: BigDecimal
    dailyVolumeToken1_lte: BigDecimal
    dailyVolumeToken1_not: BigDecimal
    dailyVolumeToken1_not_in: [BigDecimal!]
    dailyVolumeUSD: BigDecimal
    dailyVolumeUSD_gt: BigDecimal
    dailyVolumeUSD_gte: BigDecimal
    dailyVolumeUSD_in: [BigDecimal!]
    dailyVolumeUSD_lt: BigDecimal
    dailyVolumeUSD_lte: BigDecimal
    dailyVolumeUSD_not: BigDecimal
    dailyVolumeUSD_not_in: [BigDecimal!]
    date: Int
    date_gt: Int
    date_gte: Int
    date_in: [Int!]
    date_lt: Int
    date_lte: Int
    date_not: Int
    date_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    pairAddress: Bytes
    pairAddress_contains: Bytes
    pairAddress_in: [Bytes!]
    pairAddress_not: Bytes
    pairAddress_not_contains: Bytes
    pairAddress_not_in: [Bytes!]
    reserve0: BigDecimal
    reserve0_gt: BigDecimal
    reserve0_gte: BigDecimal
    reserve0_in: [BigDecimal!]
    reserve0_lt: BigDecimal
    reserve0_lte: BigDecimal
    reserve0_not: BigDecimal
    reserve0_not_in: [BigDecimal!]
    reserve1: BigDecimal
    reserve1_gt: BigDecimal
    reserve1_gte: BigDecimal
    reserve1_in: [BigDecimal!]
    reserve1_lt: BigDecimal
    reserve1_lte: BigDecimal
    reserve1_not: BigDecimal
    reserve1_not_in: [BigDecimal!]
    reserveUSD: BigDecimal
    reserveUSD_gt: BigDecimal
    reserveUSD_gte: BigDecimal
    reserveUSD_in: [BigDecimal!]
    reserveUSD_lt: BigDecimal
    reserveUSD_lte: BigDecimal
    reserveUSD_not: BigDecimal
    reserveUSD_not_in: [BigDecimal!]
    token0: String
    token0_contains: String
    token0_ends_with: String
    token0_gt: String
    token0_gte: String
    token0_in: [String!]
    token0_lt: String
    token0_lte: String
    token0_not: String
    token0_not_contains: String
    token0_not_ends_with: String
    token0_not_in: [String!]
    token0_not_starts_with: String
    token0_starts_with: String
    token1: String
    token1_contains: String
    token1_ends_with: String
    token1_gt: String
    token1_gte: String
    token1_in: [String!]
    token1_lt: String
    token1_lte: String
    token1_not: String
    token1_not_contains: String
    token1_not_ends_with: String
    token1_not_in: [String!]
    token1_not_starts_with: String
    token1_starts_with: String
    totalSupply: BigDecimal
    totalSupply_gt: BigDecimal
    totalSupply_gte: BigDecimal
    totalSupply_in: [BigDecimal!]
    totalSupply_lt: BigDecimal
    totalSupply_lte: BigDecimal
    totalSupply_not: BigDecimal
    totalSupply_not_in: [BigDecimal!]
}

enum PairDayData_orderBy {
    dailyTxns
    dailyVolumeToken0
    dailyVolumeToken1
    dailyVolumeUSD
    date
    id
    pairAddress
    reserve0
    reserve1
    reserveUSD
    token0
    token1
    totalSupply
}

type PairHourData {
    hourStartUnix: Int!
    hourlyTxns: BigInt!
    hourlyVolumeToken0: BigDecimal!
    hourlyVolumeToken1: BigDecimal!
    hourlyVolumeUSD: BigDecimal!
    id: ID!
    pair: Pair!
    reserve0: BigDecimal!
    reserve1: BigDecimal!
    reserveUSD: BigDecimal!
    totalSupply: BigDecimal!
}

input PairHourData_filter {
    hourStartUnix: Int
    hourStartUnix_gt: Int
    hourStartUnix_gte: Int
    hourStartUnix_in: [Int!]
    hourStartUnix_lt: Int
    hourStartUnix_lte: Int
    hourStartUnix_not: Int
    hourStartUnix_not_in: [Int!]
    hourlyTxns: BigInt
    hourlyTxns_gt: BigInt
    hourlyTxns_gte: BigInt
    hourlyTxns_in: [BigInt!]
    hourlyTxns_lt: BigInt
    hourlyTxns_lte: BigInt
    hourlyTxns_not: BigInt
    hourlyTxns_not_in: [BigInt!]
    hourlyVolumeToken0: BigDecimal
    hourlyVolumeToken0_gt: BigDecimal
    hourlyVolumeToken0_gte: BigDecimal
    hourlyVolumeToken0_in: [BigDecimal!]
    hourlyVolumeToken0_lt: BigDecimal
    hourlyVolumeToken0_lte: BigDecimal
    hourlyVolumeToken0_not: BigDecimal
    hourlyVolumeToken0_not_in: [BigDecimal!]
    hourlyVolumeToken1: BigDecimal
    hourlyVolumeToken1_gt: BigDecimal
    hourlyVolumeToken1_gte: BigDecimal
    hourlyVolumeToken1_in: [BigDecimal!]
    hourlyVolumeToken1_lt: BigDecimal
    hourlyVolumeToken1_lte: BigDecimal
    hourlyVolumeToken1_not: BigDecimal
    hourlyVolumeToken1_not_in: [BigDecimal!]
    hourlyVolumeUSD: BigDecimal
    hourlyVolumeUSD_gt: BigDecimal
    hourlyVolumeUSD_gte: BigDecimal
    hourlyVolumeUSD_in: [BigDecimal!]
    hourlyVolumeUSD_lt: BigDecimal
    hourlyVolumeUSD_lte: BigDecimal
    hourlyVolumeUSD_not: BigDecimal
    hourlyVolumeUSD_not_in: [BigDecimal!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    pair: String
    pair_contains: String
    pair_ends_with: String
    pair_gt: String
    pair_gte: String
    pair_in: [String!]
    pair_lt: String
    pair_lte: String
    pair_not: String
    pair_not_contains: String
    pair_not_ends_with: String
    pair_not_in: [String!]
    pair_not_starts_with: String
    pair_starts_with: String
    reserve0: BigDecimal
    reserve0_gt: BigDecimal
    reserve0_gte: BigDecimal
    reserve0_in: [BigDecimal!]
    reserve0_lt: BigDecimal
    reserve0_lte: BigDecimal
    reserve0_not: BigDecimal
    reserve0_not_in: [BigDecimal!]
    reserve1: BigDecimal
    reserve1_gt: BigDecimal
    reserve1_gte: BigDecimal
    reserve1_in: [BigDecimal!]
    reserve1_lt: BigDecimal
    reserve1_lte: BigDecimal
    reserve1_not: BigDecimal
    reserve1_not_in: [BigDecimal!]
    reserveUSD: BigDecimal
    reserveUSD_gt: BigDecimal
    reserveUSD_gte: BigDecimal
    reserveUSD_in: [BigDecimal!]
    reserveUSD_lt: BigDecimal
    reserveUSD_lte: BigDecimal
    reserveUSD_not: BigDecimal
    reserveUSD_not_in: [BigDecimal!]
    totalSupply: BigDecimal
    totalSupply_gt: BigDecimal
    totalSupply_gte: BigDecimal
    totalSupply_in: [BigDecimal!]
    totalSupply_lt: BigDecimal
    totalSupply_lte: BigDecimal
    totalSupply_not: BigDecimal
    totalSupply_not_in: [BigDecimal!]
}

enum PairHourData_orderBy {
    hourStartUnix
    hourlyTxns
    hourlyVolumeToken0
    hourlyVolumeToken1
    hourlyVolumeUSD
    id
    pair
    reserve0
    reserve1
    reserveUSD
    totalSupply
}

input Pair_filter {
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    reserve0: BigDecimal
    reserve0_gt: BigDecimal
    reserve0_gte: BigDecimal
    reserve0_in: [BigDecimal!]
    reserve0_lt: BigDecimal
    reserve0_lte: BigDecimal
    reserve0_not: BigDecimal
    reserve0_not_in: [BigDecimal!]
    reserve1: BigDecimal
    reserve1_gt: BigDecimal
    reserve1_gte: BigDecimal
    reserve1_in: [BigDecimal!]
    reserve1_lt: BigDecimal
    reserve1_lte: BigDecimal
    reserve1_not: BigDecimal
    reserve1_not_in: [BigDecimal!]
    reserveBNB: BigDecimal
    reserveBNB_gt: BigDecimal
    reserveBNB_gte: BigDecimal
    reserveBNB_in: [BigDecimal!]
    reserveBNB_lt: BigDecimal
    reserveBNB_lte: BigDecimal
    reserveBNB_not: BigDecimal
    reserveBNB_not_in: [BigDecimal!]
    reserveUSD: BigDecimal
    reserveUSD_gt: BigDecimal
    reserveUSD_gte: BigDecimal
    reserveUSD_in: [BigDecimal!]
    reserveUSD_lt: BigDecimal
    reserveUSD_lte: BigDecimal
    reserveUSD_not: BigDecimal
    reserveUSD_not_in: [BigDecimal!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token0: String
    token0Price: BigDecimal
    token0Price_gt: BigDecimal
    token0Price_gte: BigDecimal
    token0Price_in: [BigDecimal!]
    token0Price_lt: BigDecimal
    token0Price_lte: BigDecimal
    token0Price_not: BigDecimal
    token0Price_not_in: [BigDecimal!]
    token0_contains: String
    token0_ends_with: String
    token0_gt: String
    token0_gte: String
    token0_in: [String!]
    token0_lt: String
    token0_lte: String
    token0_not: String
    token0_not_contains: String
    token0_not_ends_with: String
    token0_not_in: [String!]
    token0_not_starts_with: String
    token0_starts_with: String
    token1: String
    token1Price: BigDecimal
    token1Price_gt: BigDecimal
    token1Price_gte: BigDecimal
    token1Price_in: [BigDecimal!]
    token1Price_lt: BigDecimal
    token1Price_lte: BigDecimal
    token1Price_not: BigDecimal
    token1Price_not_in: [BigDecimal!]
    token1_contains: String
    token1_ends_with: String
    token1_gt: String
    token1_gte: String
    token1_in: [String!]
    token1_lt: String
    token1_lte: String
    token1_not: String
    token1_not_contains: String
    token1_not_ends_with: String
    token1_not_in: [String!]
    token1_not_starts_with: String
    token1_starts_with: String
    totalSupply: BigDecimal
    totalSupply_gt: BigDecimal
    totalSupply_gte: BigDecimal
    totalSupply_in: [BigDecimal!]
    totalSupply_lt: BigDecimal
    totalSupply_lte: BigDecimal
    totalSupply_not: BigDecimal
    totalSupply_not_in: [BigDecimal!]
    totalTransactions: BigInt
    totalTransactions_gt: BigInt
    totalTransactions_gte: BigInt
    totalTransactions_in: [BigInt!]
    totalTransactions_lt: BigInt
    totalTransactions_lte: BigInt
    totalTransactions_not: BigInt
    totalTransactions_not_in: [BigInt!]
    trackedReserveBNB: BigDecimal
    trackedReserveBNB_gt: BigDecimal
    trackedReserveBNB_gte: BigDecimal
    trackedReserveBNB_in: [BigDecimal!]
    trackedReserveBNB_lt: BigDecimal
    trackedReserveBNB_lte: BigDecimal
    trackedReserveBNB_not: BigDecimal
    trackedReserveBNB_not_in: [BigDecimal!]
    untrackedVolumeUSD: BigDecimal
    untrackedVolumeUSD_gt: BigDecimal
    untrackedVolumeUSD_gte: BigDecimal
    untrackedVolumeUSD_in: [BigDecimal!]
    untrackedVolumeUSD_lt: BigDecimal
    untrackedVolumeUSD_lte: BigDecimal
    untrackedVolumeUSD_not: BigDecimal
    untrackedVolumeUSD_not_in: [BigDecimal!]
    volumeToken0: BigDecimal
    volumeToken0_gt: BigDecimal
    volumeToken0_gte: BigDecimal
    volumeToken0_in: [BigDecimal!]
    volumeToken0_lt: BigDecimal
    volumeToken0_lte: BigDecimal
    volumeToken0_not: BigDecimal
    volumeToken0_not_in: [BigDecimal!]
    volumeToken1: BigDecimal
    volumeToken1_gt: BigDecimal
    volumeToken1_gte: BigDecimal
    volumeToken1_in: [BigDecimal!]
    volumeToken1_lt: BigDecimal
    volumeToken1_lte: BigDecimal
    volumeToken1_not: BigDecimal
    volumeToken1_not_in: [BigDecimal!]
    volumeUSD: BigDecimal
    volumeUSD_gt: BigDecimal
    volumeUSD_gte: BigDecimal
    volumeUSD_in: [BigDecimal!]
    volumeUSD_lt: BigDecimal
    volumeUSD_lte: BigDecimal
    volumeUSD_not: BigDecimal
    volumeUSD_not_in: [BigDecimal!]
}

enum Pair_orderBy {
    block
    burns
    id
    mints
    name
    pairHourData
    reserve0
    reserve1
    reserveBNB
    reserveUSD
    swaps
    timestamp
    token0
    token0Price
    token1
    token1Price
    totalSupply
    totalTransactions
    trackedReserveBNB
    untrackedVolumeUSD
    volumeToken0
    volumeToken1
    volumeUSD
}

type PancakeDayData {
    dailyVolumeBNB: BigDecimal!
    dailyVolumeUSD: BigDecimal!
    dailyVolumeUntracked: BigDecimal!
    date: Int!
    id: ID!
    totalLiquidityBNB: BigDecimal!
    totalLiquidityUSD: BigDecimal!
    totalTransactions: BigInt!
    totalVolumeBNB: BigDecimal!
    totalVolumeUSD: BigDecimal!
}

input PancakeDayData_filter {
    dailyVolumeBNB: BigDecimal
    dailyVolumeBNB_gt: BigDecimal
    dailyVolumeBNB_gte: BigDecimal
    dailyVolumeBNB_in: [BigDecimal!]
    dailyVolumeBNB_lt: BigDecimal
    dailyVolumeBNB_lte: BigDecimal
    dailyVolumeBNB_not: BigDecimal
    dailyVolumeBNB_not_in: [BigDecimal!]
    dailyVolumeUSD: BigDecimal
    dailyVolumeUSD_gt: BigDecimal
    dailyVolumeUSD_gte: BigDecimal
    dailyVolumeUSD_in: [BigDecimal!]
    dailyVolumeUSD_lt: BigDecimal
    dailyVolumeUSD_lte: BigDecimal
    dailyVolumeUSD_not: BigDecimal
    dailyVolumeUSD_not_in: [BigDecimal!]
    dailyVolumeUntracked: BigDecimal
    dailyVolumeUntracked_gt: BigDecimal
    dailyVolumeUntracked_gte: BigDecimal
    dailyVolumeUntracked_in: [BigDecimal!]
    dailyVolumeUntracked_lt: BigDecimal
    dailyVolumeUntracked_lte: BigDecimal
    dailyVolumeUntracked_not: BigDecimal
    dailyVolumeUntracked_not_in: [BigDecimal!]
    date: Int
    date_gt: Int
    date_gte: Int
    date_in: [Int!]
    date_lt: Int
    date_lte: Int
    date_not: Int
    date_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    totalLiquidityBNB: BigDecimal
    totalLiquidityBNB_gt: BigDecimal
    totalLiquidityBNB_gte: BigDecimal
    totalLiquidityBNB_in: [BigDecimal!]
    totalLiquidityBNB_lt: BigDecimal
    totalLiquidityBNB_lte: BigDecimal
    totalLiquidityBNB_not: BigDecimal
    totalLiquidityBNB_not_in: [BigDecimal!]
    totalLiquidityUSD: BigDecimal
    totalLiquidityUSD_gt: BigDecimal
    totalLiquidityUSD_gte: BigDecimal
    totalLiquidityUSD_in: [BigDecimal!]
    totalLiquidityUSD_lt: BigDecimal
    totalLiquidityUSD_lte: BigDecimal
    totalLiquidityUSD_not: BigDecimal
    totalLiquidityUSD_not_in: [BigDecimal!]
    totalTransactions: BigInt
    totalTransactions_gt: BigInt
    totalTransactions_gte: BigInt
    totalTransactions_in: [BigInt!]
    totalTransactions_lt: BigInt
    totalTransactions_lte: BigInt
    totalTransactions_not: BigInt
    totalTransactions_not_in: [BigInt!]
    totalVolumeBNB: BigDecimal
    totalVolumeBNB_gt: BigDecimal
    totalVolumeBNB_gte: BigDecimal
    totalVolumeBNB_in: [BigDecimal!]
    totalVolumeBNB_lt: BigDecimal
    totalVolumeBNB_lte: BigDecimal
    totalVolumeBNB_not: BigDecimal
    totalVolumeBNB_not_in: [BigDecimal!]
    totalVolumeUSD: BigDecimal
    totalVolumeUSD_gt: BigDecimal
    totalVolumeUSD_gte: BigDecimal
    totalVolumeUSD_in: [BigDecimal!]
    totalVolumeUSD_lt: BigDecimal
    totalVolumeUSD_lte: BigDecimal
    totalVolumeUSD_not: BigDecimal
    totalVolumeUSD_not_in: [BigDecimal!]
}

enum PancakeDayData_orderBy {
    dailyVolumeBNB
    dailyVolumeUSD
    dailyVolumeUntracked
    date
    id
    totalLiquidityBNB
    totalLiquidityUSD
    totalTransactions
    totalVolumeBNB
    totalVolumeUSD
}

type PancakeFactory {
    id: ID!
    totalLiquidityBNB: BigDecimal!
    totalLiquidityUSD: BigDecimal!

    """
    Total of pairs
    """
    totalPairs: BigInt!

    """
    Total of transactions
    """
    totalTransactions: BigInt!
    totalVolumeBNB: BigDecimal!
    totalVolumeUSD: BigDecimal!
    untrackedVolumeUSD: BigDecimal!
}

input PancakeFactory_filter {
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    totalLiquidityBNB: BigDecimal
    totalLiquidityBNB_gt: BigDecimal
    totalLiquidityBNB_gte: BigDecimal
    totalLiquidityBNB_in: [BigDecimal!]
    totalLiquidityBNB_lt: BigDecimal
    totalLiquidityBNB_lte: BigDecimal
    totalLiquidityBNB_not: BigDecimal
    totalLiquidityBNB_not_in: [BigDecimal!]
    totalLiquidityUSD: BigDecimal
    totalLiquidityUSD_gt: BigDecimal
    totalLiquidityUSD_gte: BigDecimal
    totalLiquidityUSD_in: [BigDecimal!]
    totalLiquidityUSD_lt: BigDecimal
    totalLiquidityUSD_lte: BigDecimal
    totalLiquidityUSD_not: BigDecimal
    totalLiquidityUSD_not_in: [BigDecimal!]
    totalPairs: BigInt
    totalPairs_gt: BigInt
    totalPairs_gte: BigInt
    totalPairs_in: [BigInt!]
    totalPairs_lt: BigInt
    totalPairs_lte: BigInt
    totalPairs_not: BigInt
    totalPairs_not_in: [BigInt!]
    totalTransactions: BigInt
    totalTransactions_gt: BigInt
    totalTransactions_gte: BigInt
    totalTransactions_in: [BigInt!]
    totalTransactions_lt: BigInt
    totalTransactions_lte: BigInt
    totalTransactions_not: BigInt
    totalTransactions_not_in: [BigInt!]
    totalVolumeBNB: BigDecimal
    totalVolumeBNB_gt: BigDecimal
    totalVolumeBNB_gte: BigDecimal
    totalVolumeBNB_in: [BigDecimal!]
    totalVolumeBNB_lt: BigDecimal
    totalVolumeBNB_lte: BigDecimal
    totalVolumeBNB_not: BigDecimal
    totalVolumeBNB_not_in: [BigDecimal!]
    totalVolumeUSD: BigDecimal
    totalVolumeUSD_gt: BigDecimal
    totalVolumeUSD_gte: BigDecimal
    totalVolumeUSD_in: [BigDecimal!]
    totalVolumeUSD_lt: BigDecimal
    totalVolumeUSD_lte: BigDecimal
    totalVolumeUSD_not: BigDecimal
    totalVolumeUSD_not_in: [BigDecimal!]
    untrackedVolumeUSD: BigDecimal
    untrackedVolumeUSD_gt: BigDecimal
    untrackedVolumeUSD_gte: BigDecimal
    untrackedVolumeUSD_in: [BigDecimal!]
    untrackedVolumeUSD_lt: BigDecimal
    untrackedVolumeUSD_lte: BigDecimal
    untrackedVolumeUSD_not: BigDecimal
    untrackedVolumeUSD_not_in: [BigDecimal!]
}

enum PancakeFactory_orderBy {
    id
    totalLiquidityBNB
    totalLiquidityUSD
    totalPairs
    totalTransactions
    totalVolumeBNB
    totalVolumeUSD
    untrackedVolumeUSD
}

type Query {
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
    block(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Block
    blocks(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Block_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Block_filter
    ): [Block!]!
    bundle(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Bundle
    bundles(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Bundle_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Bundle_filter
    ): [Bundle!]!
    burn(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Burn
    burns(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Burn_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Burn_filter
    ): [Burn!]!
    mint(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Mint
    mints(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Mint_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Mint_filter
    ): [Mint!]!
    pair(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Pair
    pairDayData(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PairDayData
    pairDayDatas(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PairDayData_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PairDayData_filter
    ): [PairDayData!]!
    pairHourData(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PairHourData
    pairHourDatas(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PairHourData_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PairHourData_filter
    ): [PairHourData!]!
    pairs(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Pair_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Pair_filter
    ): [Pair!]!
    pancakeDayData(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PancakeDayData
    pancakeDayDatas(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PancakeDayData_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PancakeDayData_filter
    ): [PancakeDayData!]!
    pancakeFactories(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PancakeFactory_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PancakeFactory_filter
    ): [PancakeFactory!]!
    pancakeFactory(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PancakeFactory
    swap(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Swap
    swaps(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Swap_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Swap_filter
    ): [Swap!]!
    token(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokenDayData(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenDayData
    tokenDayDatas(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: TokenDayData_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: TokenDayData_filter
    ): [TokenDayData!]!
    tokens(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Token_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Token_filter
    ): [Token!]!
    transaction(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Transaction
    transactions(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Transaction_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Transaction_filter
    ): [Transaction!]!
}

type Subscription {
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
    block(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Block
    blocks(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Block_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Block_filter
    ): [Block!]!
    bundle(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Bundle
    bundles(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Bundle_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Bundle_filter
    ): [Bundle!]!
    burn(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Burn
    burns(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Burn_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Burn_filter
    ): [Burn!]!
    mint(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Mint
    mints(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Mint_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Mint_filter
    ): [Mint!]!
    pair(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Pair
    pairDayData(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PairDayData
    pairDayDatas(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PairDayData_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PairDayData_filter
    ): [PairDayData!]!
    pairHourData(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PairHourData
    pairHourDatas(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PairHourData_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PairHourData_filter
    ): [PairHourData!]!
    pairs(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Pair_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Pair_filter
    ): [Pair!]!
    pancakeDayData(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PancakeDayData
    pancakeDayDatas(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PancakeDayData_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PancakeDayData_filter
    ): [PancakeDayData!]!
    pancakeFactories(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: PancakeFactory_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: PancakeFactory_filter
    ): [PancakeFactory!]!
    pancakeFactory(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PancakeFactory
    swap(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Swap
    swaps(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Swap_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Swap_filter
    ): [Swap!]!
    token(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokenDayData(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenDayData
    tokenDayDatas(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: TokenDayData_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: TokenDayData_filter
    ): [TokenDayData!]!
    tokens(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Token_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Token_filter
    ): [Token!]!
    transaction(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        id: ID!

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Transaction
    transactions(
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        first: Int = 100
        orderBy: Transaction_orderBy
        orderDirection: OrderDirection
        skip: Int = 0

        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
        where: Transaction_filter
    ): [Transaction!]!
}

type Swap {
    amount0In: BigDecimal!
    amount0Out: BigDecimal!
    amount1In: BigDecimal!
    amount1Out: BigDecimal!
    amountUSD: BigDecimal!
    from: Bytes!
    id: ID!
    logIndex: BigInt
    pair: Pair!
    sender: Bytes!
    timestamp: BigInt!
    to: Bytes!
    transaction: Transaction!
}

input Swap_filter {
    amount0In: BigDecimal
    amount0In_gt: BigDecimal
    amount0In_gte: BigDecimal
    amount0In_in: [BigDecimal!]
    amount0In_lt: BigDecimal
    amount0In_lte: BigDecimal
    amount0In_not: BigDecimal
    amount0In_not_in: [BigDecimal!]
    amount0Out: BigDecimal
    amount0Out_gt: BigDecimal
    amount0Out_gte: BigDecimal
    amount0Out_in: [BigDecimal!]
    amount0Out_lt: BigDecimal
    amount0Out_lte: BigDecimal
    amount0Out_not: BigDecimal
    amount0Out_not_in: [BigDecimal!]
    amount1In: BigDecimal
    amount1In_gt: BigDecimal
    amount1In_gte: BigDecimal
    amount1In_in: [BigDecimal!]
    amount1In_lt: BigDecimal
    amount1In_lte: BigDecimal
    amount1In_not: BigDecimal
    amount1In_not_in: [BigDecimal!]
    amount1Out: BigDecimal
    amount1Out_gt: BigDecimal
    amount1Out_gte: BigDecimal
    amount1Out_in: [BigDecimal!]
    amount1Out_lt: BigDecimal
    amount1Out_lte: BigDecimal
    amount1Out_not: BigDecimal
    amount1Out_not_in: [BigDecimal!]
    amountUSD: BigDecimal
    amountUSD_gt: BigDecimal
    amountUSD_gte: BigDecimal
    amountUSD_in: [BigDecimal!]
    amountUSD_lt: BigDecimal
    amountUSD_lte: BigDecimal
    amountUSD_not: BigDecimal
    amountUSD_not_in: [BigDecimal!]
    from: Bytes
    from_contains: Bytes
    from_in: [Bytes!]
    from_not: Bytes
    from_not_contains: Bytes
    from_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    logIndex: BigInt
    logIndex_gt: BigInt
    logIndex_gte: BigInt
    logIndex_in: [BigInt!]
    logIndex_lt: BigInt
    logIndex_lte: BigInt
    logIndex_not: BigInt
    logIndex_not_in: [BigInt!]
    pair: String
    pair_contains: String
    pair_ends_with: String
    pair_gt: String
    pair_gte: String
    pair_in: [String!]
    pair_lt: String
    pair_lte: String
    pair_not: String
    pair_not_contains: String
    pair_not_ends_with: String
    pair_not_in: [String!]
    pair_not_starts_with: String
    pair_starts_with: String
    sender: Bytes
    sender_contains: Bytes
    sender_in: [Bytes!]
    sender_not: Bytes
    sender_not_contains: Bytes
    sender_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    to: Bytes
    to_contains: Bytes
    to_in: [Bytes!]
    to_not: Bytes
    to_not_contains: Bytes
    to_not_in: [Bytes!]
    transaction: String
    transaction_contains: String
    transaction_ends_with: String
    transaction_gt: String
    transaction_gte: String
    transaction_in: [String!]
    transaction_lt: String
    transaction_lte: String
    transaction_not: String
    transaction_not_contains: String
    transaction_not_ends_with: String
    transaction_not_in: [String!]
    transaction_not_starts_with: String
    transaction_starts_with: String
}

enum Swap_orderBy {
    amount0In
    amount0Out
    amount1In
    amount1Out
    amountUSD
    from
    id
    logIndex
    pair
    sender
    timestamp
    to
    transaction
}

type Token {
    """
    Decimals
    """
    decimals: BigInt!
    derivedBNB: BigDecimal
    derivedUSD: BigDecimal
    id: ID!

    """
    Name
    """
    name: String!
    pairBase(
        first: Int = 100
        orderBy: Pair_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Pair_filter
    ): [Pair!]!
    pairDayDataBase(
        first: Int = 100
        orderBy: PairDayData_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: PairDayData_filter
    ): [PairDayData!]!
    pairDayDataQuote(
        first: Int = 100
        orderBy: PairDayData_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: PairDayData_filter
    ): [PairDayData!]!
    pairQuote(
        first: Int = 100
        orderBy: Pair_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Pair_filter
    ): [Pair!]!

    """
    Symbol
    """
    symbol: String!
    tokenDayData(
        first: Int = 100
        orderBy: TokenDayData_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: TokenDayData_filter
    ): [TokenDayData!]!
    totalLiquidity: BigDecimal!
    totalTransactions: BigInt!
    tradeVolume: BigDecimal!
    tradeVolumeUSD: BigDecimal!
    untrackedVolumeUSD: BigDecimal!
}

type TokenDayData {
    dailyTxns: BigInt!
    dailyVolumeBNB: BigDecimal!
    dailyVolumeToken: BigDecimal!
    dailyVolumeUSD: BigDecimal!
    date: Int!
    id: ID!
    priceUSD: BigDecimal!
    token: Token!
    totalLiquidityBNB: BigDecimal!
    totalLiquidityToken: BigDecimal!
    totalLiquidityUSD: BigDecimal!
}

input TokenDayData_filter {
    dailyTxns: BigInt
    dailyTxns_gt: BigInt
    dailyTxns_gte: BigInt
    dailyTxns_in: [BigInt!]
    dailyTxns_lt: BigInt
    dailyTxns_lte: BigInt
    dailyTxns_not: BigInt
    dailyTxns_not_in: [BigInt!]
    dailyVolumeBNB: BigDecimal
    dailyVolumeBNB_gt: BigDecimal
    dailyVolumeBNB_gte: BigDecimal
    dailyVolumeBNB_in: [BigDecimal!]
    dailyVolumeBNB_lt: BigDecimal
    dailyVolumeBNB_lte: BigDecimal
    dailyVolumeBNB_not: BigDecimal
    dailyVolumeBNB_not_in: [BigDecimal!]
    dailyVolumeToken: BigDecimal
    dailyVolumeToken_gt: BigDecimal
    dailyVolumeToken_gte: BigDecimal
    dailyVolumeToken_in: [BigDecimal!]
    dailyVolumeToken_lt: BigDecimal
    dailyVolumeToken_lte: BigDecimal
    dailyVolumeToken_not: BigDecimal
    dailyVolumeToken_not_in: [BigDecimal!]
    dailyVolumeUSD: BigDecimal
    dailyVolumeUSD_gt: BigDecimal
    dailyVolumeUSD_gte: BigDecimal
    dailyVolumeUSD_in: [BigDecimal!]
    dailyVolumeUSD_lt: BigDecimal
    dailyVolumeUSD_lte: BigDecimal
    dailyVolumeUSD_not: BigDecimal
    dailyVolumeUSD_not_in: [BigDecimal!]
    date: Int
    date_gt: Int
    date_gte: Int
    date_in: [Int!]
    date_lt: Int
    date_lte: Int
    date_not: Int
    date_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    priceUSD: BigDecimal
    priceUSD_gt: BigDecimal
    priceUSD_gte: BigDecimal
    priceUSD_in: [BigDecimal!]
    priceUSD_lt: BigDecimal
    priceUSD_lte: BigDecimal
    priceUSD_not: BigDecimal
    priceUSD_not_in: [BigDecimal!]
    token: String
    token_contains: String
    token_ends_with: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_ends_with: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_starts_with: String
    totalLiquidityBNB: BigDecimal
    totalLiquidityBNB_gt: BigDecimal
    totalLiquidityBNB_gte: BigDecimal
    totalLiquidityBNB_in: [BigDecimal!]
    totalLiquidityBNB_lt: BigDecimal
    totalLiquidityBNB_lte: BigDecimal
    totalLiquidityBNB_not: BigDecimal
    totalLiquidityBNB_not_in: [BigDecimal!]
    totalLiquidityToken: BigDecimal
    totalLiquidityToken_gt: BigDecimal
    totalLiquidityToken_gte: BigDecimal
    totalLiquidityToken_in: [BigDecimal!]
    totalLiquidityToken_lt: BigDecimal
    totalLiquidityToken_lte: BigDecimal
    totalLiquidityToken_not: BigDecimal
    totalLiquidityToken_not_in: [BigDecimal!]
    totalLiquidityUSD: BigDecimal
    totalLiquidityUSD_gt: BigDecimal
    totalLiquidityUSD_gte: BigDecimal
    totalLiquidityUSD_in: [BigDecimal!]
    totalLiquidityUSD_lt: BigDecimal
    totalLiquidityUSD_lte: BigDecimal
    totalLiquidityUSD_not: BigDecimal
    totalLiquidityUSD_not_in: [BigDecimal!]
}

enum TokenDayData_orderBy {
    dailyTxns
    dailyVolumeBNB
    dailyVolumeToken
    dailyVolumeUSD
    date
    id
    priceUSD
    token
    totalLiquidityBNB
    totalLiquidityToken
    totalLiquidityUSD
}

input Token_filter {
    decimals: BigInt
    decimals_gt: BigInt
    decimals_gte: BigInt
    decimals_in: [BigInt!]
    decimals_lt: BigInt
    decimals_lte: BigInt
    decimals_not: BigInt
    decimals_not_in: [BigInt!]
    derivedBNB: BigDecimal
    derivedBNB_gt: BigDecimal
    derivedBNB_gte: BigDecimal
    derivedBNB_in: [BigDecimal!]
    derivedBNB_lt: BigDecimal
    derivedBNB_lte: BigDecimal
    derivedBNB_not: BigDecimal
    derivedBNB_not_in: [BigDecimal!]
    derivedUSD: BigDecimal
    derivedUSD_gt: BigDecimal
    derivedUSD_gte: BigDecimal
    derivedUSD_in: [BigDecimal!]
    derivedUSD_lt: BigDecimal
    derivedUSD_lte: BigDecimal
    derivedUSD_not: BigDecimal
    derivedUSD_not_in: [BigDecimal!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    symbol: String
    symbol_contains: String
    symbol_ends_with: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_ends_with: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_starts_with: String
    totalLiquidity: BigDecimal
    totalLiquidity_gt: BigDecimal
    totalLiquidity_gte: BigDecimal
    totalLiquidity_in: [BigDecimal!]
    totalLiquidity_lt: BigDecimal
    totalLiquidity_lte: BigDecimal
    totalLiquidity_not: BigDecimal
    totalLiquidity_not_in: [BigDecimal!]
    totalTransactions: BigInt
    totalTransactions_gt: BigInt
    totalTransactions_gte: BigInt
    totalTransactions_in: [BigInt!]
    totalTransactions_lt: BigInt
    totalTransactions_lte: BigInt
    totalTransactions_not: BigInt
    totalTransactions_not_in: [BigInt!]
    tradeVolume: BigDecimal
    tradeVolumeUSD: BigDecimal
    tradeVolumeUSD_gt: BigDecimal
    tradeVolumeUSD_gte: BigDecimal
    tradeVolumeUSD_in: [BigDecimal!]
    tradeVolumeUSD_lt: BigDecimal
    tradeVolumeUSD_lte: BigDecimal
    tradeVolumeUSD_not: BigDecimal
    tradeVolumeUSD_not_in: [BigDecimal!]
    tradeVolume_gt: BigDecimal
    tradeVolume_gte: BigDecimal
    tradeVolume_in: [BigDecimal!]
    tradeVolume_lt: BigDecimal
    tradeVolume_lte: BigDecimal
    tradeVolume_not: BigDecimal
    tradeVolume_not_in: [BigDecimal!]
    untrackedVolumeUSD: BigDecimal
    untrackedVolumeUSD_gt: BigDecimal
    untrackedVolumeUSD_gte: BigDecimal
    untrackedVolumeUSD_in: [BigDecimal!]
    untrackedVolumeUSD_lt: BigDecimal
    untrackedVolumeUSD_lte: BigDecimal
    untrackedVolumeUSD_not: BigDecimal
    untrackedVolumeUSD_not_in: [BigDecimal!]
}

enum Token_orderBy {
    decimals
    derivedBNB
    derivedUSD
    id
    name
    pairBase
    pairDayDataBase
    pairDayDataQuote
    pairQuote
    symbol
    tokenDayData
    totalLiquidity
    totalTransactions
    tradeVolume
    tradeVolumeUSD
    untrackedVolumeUSD
}

type Transaction {
    block: BigInt!
    burns(
        first: Int = 100
        orderBy: Burn_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Burn_filter
    ): [Burn]!
    id: ID!
    mints(
        first: Int = 100
        orderBy: Mint_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Mint_filter
    ): [Mint]!
    swaps(
        first: Int = 100
        orderBy: Swap_orderBy
        orderDirection: OrderDirection
        skip: Int = 0
        where: Swap_filter
    ): [Swap]!
    timestamp: BigInt!
}

input Transaction_filter {
    block: BigInt
    block_gt: BigInt
    block_gte: BigInt
    block_in: [BigInt!]
    block_lt: BigInt
    block_lte: BigInt
    block_not: BigInt
    block_not_in: [BigInt!]
    burns: [String!]
    burns_contains: [String!]
    burns_not: [String!]
    burns_not_contains: [String!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    mints: [String!]
    mints_contains: [String!]
    mints_not: [String!]
    mints_not_contains: [String!]
    swaps: [String!]
    swaps_contains: [String!]
    swaps_not: [String!]
    swaps_not_contains: [String!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
}

enum Transaction_orderBy {
    block
    burns
    id
    mints
    swaps
    timestamp
}

type _Block_ {
    """
    The hash of the block
    """
    hash: Bytes

    """
    The block number
    """
    number: Int!
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
    "Information about a specific subgraph block. The hash of the block\nwill be null if the _meta field has a block constraint that asks for\na block number. It will be filled if the _meta field has no block constraint\nand therefore asks for the latest  block\n"
    block: _Block_!

    """
    The deployment ID
    """
    deployment: String!

    """
    If `true`, the subgraph encountered indexing errors at some past block
    """
    hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
    """
    Data will be returned even if the subgraph has indexing errors
    """
    allow

    """
    If the subgraph has indexing errors, data will be omitted. The default.
    """
    deny
}
